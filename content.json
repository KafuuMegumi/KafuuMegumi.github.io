{"meta":{"title":"KafuuMegumi's Kingdom","subtitle":null,"description":null,"author":"KafuuMegumi","url":"http://kafuumegumi.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-15","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-15","excerpt":""}],"posts":[{"title":"牛客多校第一场-C-Euclidean Distance","text":"题目: 解题思路:可以先把分母m提到外面去,题目转化为对n个数,你可以改变任意数量的数使他们值变小,但变小的值的总和要等于m,之后再求这n个数的平方和最小值.假设 a＜b,则a×a-(a-c)×(a-c)＜b×b-(b-c)×(b-c),减去相同的数越大的数他的平方值变化越大,因此贪心选取最大的数改变他的值一定是最优的,由于改变的值不一定为整数,但一定是最大的几个数变成一个相等的值,且这个值一定比其他没改变的数都大,于是我们先把a从大到小排序,然后枚举最大的多少项会变成相等的值,分别求出分子和分母再做约分就可以了.1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod=1e9+7;const int N=1e4+5;int a[N],sum[N];ll pw2(int x)&#123;return 1ll*x*x;&#125;int main()&#123; int n,m; while(~scanf(\"%d%d\",&amp;n,&amp;m))&#123; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; sort(a+1,a+n+1,greater&lt;int&gt;()); for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i]; ll p=0,q=0; for(int i=1;i&lt;=n+1;i++)&#123; if(sum[i]-i*a[i]&gt;m||i==n+1)&#123; int res=sum[i-1]-(i-1)*a[i-1]; p+=pw2(a[i-1]*(i-1)-(m-res)); q+=1ll*(i-1)*m*m; for(int j=i;j&lt;=n;j++)&#123; p+=1ll*(i-1)*pw2(a[j]); &#125; break; &#125; &#125; ll g=__gcd(p,q); p/=g;q/=g; if(q&gt;1)printf(\"%lld/%lld\\n\",p,q); else printf(\"%lld\\n\",p); &#125; return 0;&#125;","path":"牛客多校第一场-C-Euclidean-Distance/","date":"07-19","excerpt":"","tags":[{"name":"数学/贪心","slug":"数学-贪心","permalink":"http://kafuumegumi.github.io/tags/数学-贪心/"}]},{"title":"牛客多校第一场-B-Integration","text":"题目: 解题思路:题目给出∫(dx/(1+x^2))=π/2(x=0-&gt;∞),于是推出∫(dx/(a^2+x^2))=π/2a.观察到题目要求的是∫(dx/∏(ai^2+x^2)),于是我们想到把分母拆开来变成n项相加,分母为(ai^2+x^2),分子可以用待定系数求得,算出来是∏(aj^2-ai^2)//(j!=i),拆开来之后对于每一项分别积分然后再相加答案就出来了.123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod=1e9+7;ll a[2005];ll qpow(ll a,int b)&#123; ll res=1; for(;b;b&gt;&gt;=1,a=a*a%mod) if(b&amp;1)res=res*a%mod; return res;&#125;int main()&#123; int n; while(~scanf(\"%d\",&amp;n))&#123; ll ans=0; for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; ll res=2*a[i]%mod; for(int j=1;j&lt;=n;j++) if(i!=j) res=(a[j]*a[j]-a[i]*a[i])%mod*res%mod; res=(res+mod)%mod; ans+=qpow(res,mod-2); ans%=mod; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"牛客多校第一场-B-Integration/","date":"07-18","excerpt":"","tags":[{"name":"数学","slug":"数学","permalink":"http://kafuumegumi.github.io/tags/数学/"}]},{"title":"CF 572 B Count Pairs","text":"大致题意:给n,p,k,p是质数,还有n个数 a[1],a[2],…,a[n].求有多少对(i,j)满足(a[i]+a[j])(a[i]^2+a[j]^2)%p==k.(2&lt;=n&lt;=3e5 2&lt;=p&lt;=1e9 0&lt;=k&lt;=p-1) 解题思路:(a[i]+a[j])(a[i]^2+a[j]^2) = (a[i]^4-a[j]^4)/(a[i]-a[j]),化简得 (a[i]^4-k×a[i])-(a[j]^4-k×a[j])%p==k,于是只要把(a[i]^4-k×a[i])%p 的余数算出来就知道答案了.123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=3e5+5;int a[N];map&lt;int,int&gt;mp;int main()&#123; int n,p,k; scanf(\"%d%d%d\",&amp;n,&amp;p,&amp;k); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; a[i]=(1ll*a[i]*a[i]%p*a[i]%p*a[i]%p-1ll*k*a[i]%p+p)%p; mp[a[i]]++; &#125; ll ans=0; for(int i=1;i&lt;=n;i++)&#123; ans+=mp[a[i]]-1; &#125; printf(\"%lld\\n\",ans/2);&#125;","path":"CF-572-Count-Pairs/","date":"07-15","excerpt":"","tags":[{"name":"数学","slug":"数学","permalink":"http://kafuumegumi.github.io/tags/数学/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"hello-world/","date":"07-15","excerpt":"","tags":[]}]}