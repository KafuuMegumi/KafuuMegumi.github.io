{"meta":{"title":"KafuuMegumi's Kingdom","subtitle":null,"description":null,"author":"KafuuMegumi","url":"http://kafuumegumi.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-15","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-15","excerpt":""}],"posts":[{"title":"链接collection","text":"多项式 从多项式乘法到快速傅里叶变换 十分简明易懂的FFT 【总结】FWT算法 多项式相关算法及模板（未完待续） NTT模数表 线性基 线性基求交模板","path":"链接collection/","date":"07-28","excerpt":"","tags":[{"name":"链接","slug":"链接","permalink":"http://kafuumegumi.github.io/tags/链接/"}]},{"title":"hdu 2019 Multi-University Training Contest 2 Function","text":"题目:求.(n&lt;=1e21) 解题思路:推出式子之后就可以分块求解.式子推法可以参考公式推导 总结:中间用到了这么一个公式.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;template &lt;class T&gt;void read(T &amp;x) &#123; static char ch;static bool neg; for(ch=neg=0;ch&lt;'0' || '9'&lt;ch;neg|=ch=='-',ch=getchar()); for(x=0;'0'&lt;=ch &amp;&amp; ch&lt;='9';(x*=10)+=ch-'0',ch=getchar()); x=neg?-x:x;&#125;const int N=1e7+5;const int mod=998244353;int p[N],tot;int phi[N];bool v[N];void moblus()&#123; phi[1]=1;tot=0; for(int i=2;i&lt;N;i++)&#123; if(!v[i])p[tot++]=i,phi[i]=i-1; for(int j=0;i*p[j]&lt;N&amp;&amp;j&lt;tot;j++)&#123; v[i*p[j]]=1; if(i%p[j])phi[i*p[j]]=phi[i]*phi[p[j]]; else&#123; phi[i*p[j]]=phi[i]*p[j]; break; &#125; &#125; &#125;&#125;ll calc(int n,__int128 L,__int128 R)&#123; ll res=0; for(int i=1;i*i&lt;=n;i++)&#123; if(n%i==0)&#123; res+=(R/i-L/i)%mod*phi[i]%mod; res%=mod; if(i*i!=n)&#123; int j=n/i; res+=(R/j-L/j)%mod*phi[j]%mod; res%=mod; &#125; &#125; &#125; return res;&#125;inline ll sum(ll x)&#123; return x*(x+1)/2%mod;&#125;inline ll sum2(ll x)&#123; return x*(x+1)%(6ll*mod)*(2*x+1)/6%mod;&#125;inline int add(int a,int b)&#123; return (a+=b)&gt;=mod?a-mod:a;&#125;int main()&#123; int T; moblus(); scanf(\"%d\",&amp;T); for(;T--;)&#123; __int128 n; read(n); __int128 r=1; for(;(r+1)*(r+1)*(r+1)-1&lt;=n;r++); ll ans=calc(r,r*r*r-1,n); r--; for(int i=1;i&lt;=r;i++)&#123; int j=r/i; ans=add(ans,1ll*add(sum2(j)*i*3%mod,add(sum(j)*3%mod,j))*phi[i]%mod); &#125; printf(\"%lld\\n\",ans); &#125;&#125;","path":"hdu-2019-Multi-University-Training-Contest-2-Function/","date":"07-26","excerpt":"","tags":[{"name":"数学","slug":"数学","permalink":"http://kafuumegumi.github.io/tags/数学/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://kafuumegumi.github.io/tags/莫比乌斯反演/"}]},{"title":"hdu 2019 Multi-University Training Contest 2 Meteor","text":"题目:给出n,k,求分子分母都不大于n的第k小分数.(n&lt;=1e6,保证答案在(0,1]) 解题思路:对于一个值k,我们可以通过如下推导得出分子分母都不大于n并且小于等于k的分数个数.然后可以通过类欧和分块求出这个值.至于k可以二分求得.问题现在变成对于一个k找到一个小于等于k并且分子分母都不大于n的最大分数,可以枚举分母然后即可贪心求得满足条件的最大分子,最后维护一下最大值即可.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct frac&#123; ll p,q; frac operator+(const frac&amp;x)const&#123; frac tmp; tmp.q=q/__gcd(q,x.q)*x.q; tmp.p=p*(tmp.q/q)+x.p*(tmp.q/x.q); return tmp; &#125; frac operator/(const int x)const&#123; frac tmp; tmp.p=p; tmp.q=q*x; ll g=__gcd(tmp.p,tmp.q); tmp.p/=g;tmp.q/=g; return tmp; &#125; bool operator&lt;(const frac &amp;x)const&#123; return p*x.q&lt;q*x.p; &#125;&#125;;const int N=1e6+5;ll mu[N],tot,p[N],sum_mu[N];bool v[N];void moblus()&#123; memset(v,0,sizeof v); mu[1]=1;tot=0; for(int i=2;i&lt;N;i++)&#123; if(!v[i])p[tot++]=i,mu[i]=-1; for(int j=0;i*p[j]&lt;N&amp;&amp;j&lt;tot;j++)&#123; v[i*p[j]]=1; if(i%p[j])mu[i*p[j]]=-mu[i]; else&#123; mu[i*p[j]]=0; break; &#125; &#125; &#125; sum_mu[0]=0; for(int i=1;i&lt;N;i++)sum_mu[i]=sum_mu[i-1]+mu[i];&#125;ll f(ll a,ll b,ll c,ll n)&#123; if(!a)return 0; if(a&gt;=c||b&gt;=c)&#123; return n*(n+1)/2*(a/c)+b/c*(n+1)+f(a%c,b%c,c,n); &#125; ll m=(a*n+b)/c; return n*m-f(c,c-b-1,a,m-1);&#125;ll calc(const frac&amp;x,ll n)&#123; ll res=0; for(int i=1;i&lt;=n;)&#123; int j=n/(n/i); res+=(sum_mu[j]-sum_mu[i-1])*f(x.p,0,x.q,n/i); i=j+1; &#125; return res;&#125;frac find(const frac&amp;x,ll n)&#123; frac tmp=&#123;1,1&#125;; for(int i=1;i&lt;=n;i++)&#123; tmp=min(tmp,(frac)&#123;(x.p*i)/x.q+1,i&#125;); &#125; ll g=__gcd(tmp.p,tmp.q); tmp.p/=g;tmp.q/=g; return tmp;&#125;int main()&#123; moblus(); int T; scanf(\"%d\",&amp;T); for(;T--;)&#123; ll n,k; scanf(\"%lld%lld\",&amp;n,&amp;k); frac L=&#123;0,1&#125;,R=&#123;1,1&#125;; for(int i=0;i&lt;=40;i++)&#123; frac mid=(L+R)/2; ll cnt=calc(mid,n); if(cnt&lt;k)&#123; L=mid; if(cnt==k-1)break; &#125; else R=mid; &#125; frac ans=find(L,n); printf(\"%lld/%lld\\n\",ans.p,ans.q); &#125;&#125;","path":"hdu-2019-Multi-University-Training-Contest-2-Meteor/","date":"07-26","excerpt":"","tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://kafuumegumi.github.io/tags/莫比乌斯反演/"},{"name":"二分","slug":"二分","permalink":"http://kafuumegumi.github.io/tags/二分/"}]},{"title":"牛客多校第一场-C-Euclidean Distance","text":"题目: 解题思路:可以先把分母m提到外面去,题目转化为对n个数,你可以改变任意数量的数使他们值变小,但变小的值的总和要等于m,之后再求这n个数的平方和最小值.假设 a＜b,则a×a-(a-c)×(a-c)＜b×b-(b-c)×(b-c),减去相同的数越大的数他的平方值变化越大,因此贪心选取最大的数改变他的值一定是最优的,由于改变的值不一定为整数,但一定是最大的几个数变成一个相等的值,且这个值一定比其他没改变的数都大,于是我们先把a从大到小排序,然后枚举最大的多少项会变成相等的值,分别求出分子和分母再做约分就可以了.1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod=1e9+7;const int N=1e4+5;int a[N],sum[N];ll pw2(int x)&#123;return 1ll*x*x;&#125;int main()&#123; int n,m; while(~scanf(\"%d%d\",&amp;n,&amp;m))&#123; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; sort(a+1,a+n+1,greater&lt;int&gt;()); for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i]; ll p=0,q=0; for(int i=1;i&lt;=n+1;i++)&#123; if(sum[i]-i*a[i]&gt;m||i==n+1)&#123; int res=sum[i-1]-(i-1)*a[i-1]; p+=pw2(a[i-1]*(i-1)-(m-res)); q+=1ll*(i-1)*m*m; for(int j=i;j&lt;=n;j++)&#123; p+=1ll*(i-1)*pw2(a[j]); &#125; break; &#125; &#125; ll g=__gcd(p,q); p/=g;q/=g; if(q&gt;1)printf(\"%lld/%lld\\n\",p,q); else printf(\"%lld\\n\",p); &#125; return 0;&#125;","path":"牛客多校第一场-C-Euclidean-Distance/","date":"07-19","excerpt":"","tags":[{"name":"数学","slug":"数学","permalink":"http://kafuumegumi.github.io/tags/数学/"},{"name":"贪心","slug":"贪心","permalink":"http://kafuumegumi.github.io/tags/贪心/"}]},{"title":"牛客多校第一场-B-Integration","text":"题目: 解题思路:题目给出∫(dx/(1+x^2))=π/2(x=0-&gt;∞),于是推出∫(dx/(a^2+x^2))=π/2a.观察到题目要求的是∫(dx/∏(ai^2+x^2)),于是我们想到把分母拆开来变成n项相加,分母为(ai^2+x^2),分子可以用待定系数求得,算出来是∏(aj^2-ai^2)//(j!=i),拆开来之后对于每一项分别积分然后再相加答案就出来了.123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int mod=1e9+7;ll a[2005];ll qpow(ll a,int b)&#123; ll res=1; for(;b;b&gt;&gt;=1,a=a*a%mod) if(b&amp;1)res=res*a%mod; return res;&#125;int main()&#123; int n; while(~scanf(\"%d\",&amp;n))&#123; ll ans=0; for(int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; ll res=2*a[i]%mod; for(int j=1;j&lt;=n;j++) if(i!=j) res=(a[j]*a[j]-a[i]*a[i])%mod*res%mod; res=(res+mod)%mod; ans+=qpow(res,mod-2); ans%=mod; &#125; printf(\"%lld\\n\",ans); &#125; return 0;&#125;","path":"牛客多校第一场-B-Integration/","date":"07-18","excerpt":"","tags":[{"name":"数学","slug":"数学","permalink":"http://kafuumegumi.github.io/tags/数学/"}]},{"title":"CF 572 B Count Pairs","text":"大致题意:给n,p,k,p是质数,还有n个数 a[1],a[2],…,a[n].求有多少对(i,j)满足(a[i]+a[j])(a[i]^2+a[j]^2)%p==k.(2&lt;=n&lt;=3e5 2&lt;=p&lt;=1e9 0&lt;=k&lt;=p-1) 解题思路:(a[i]+a[j])(a[i]^2+a[j]^2) = (a[i]^4-a[j]^4)/(a[i]-a[j]),化简得 (a[i]^4-k×a[i])-(a[j]^4-k×a[j])%p==k,于是只要把(a[i]^4-k×a[i])%p 的余数算出来就知道答案了.123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=3e5+5;int a[N];map&lt;int,int&gt;mp;int main()&#123; int n,p,k; scanf(\"%d%d%d\",&amp;n,&amp;p,&amp;k); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); for(int i=1;i&lt;=n;i++)&#123; a[i]=(1ll*a[i]*a[i]%p*a[i]%p*a[i]%p-1ll*k*a[i]%p+p)%p; mp[a[i]]++; &#125; ll ans=0; for(int i=1;i&lt;=n;i++)&#123; ans+=mp[a[i]]-1; &#125; printf(\"%lld\\n\",ans/2);&#125;","path":"CF-572-Count-Pairs/","date":"07-15","excerpt":"","tags":[{"name":"数学","slug":"数学","permalink":"http://kafuumegumi.github.io/tags/数学/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"hello-world/","date":"07-15","excerpt":"","tags":[]}]}